<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Fri Jan 30 10:04:27 GMT+03:30 1998
-->
<title>
Class HTTPClient.Codecs
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-HTTPClient.html">This Package</a>  <a href="HTTPClient.AuthorizationInfo.html">Previous</a>  <a href="HTTPClient.Cookie.html">Next</a>  <a href="Index.html">Index</a>  </pre>
<hr>
<h1>
Class HTTPClient.Codecs
</h1>
<pre>
java.lang.Object
    |
    +----HTTPClient.Codecs
</pre>
<hr>
<dl>
<dt>public class <b>Codecs</b>
<dt>extends Object</dl>
This class collects various encoders and decoders.
<p>
<dl>
<dt><b>Version:</b>
 <dd>0.3  30/01/1998
<dt><b>Author:</b>
 <dd>Ronald Tschal&auml;r
</dl>
<hr>
<a name="index"></a><h2>
<img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#base64Decode(byte[])"><b>base64Decode</b></a>(byte[])
<dd>This method decodes the given byte[] using the base64-encoding
specified in RFC-2045 (Section 6.8).
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#base64Decode(java.lang.String)"><b>base64Decode</b></a>(String)
<dd>This method decodes the given string using the base64-encoding
specified in RFC-2045 (Section 6.8).
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#base64Encode(byte[])"><b>base64Encode</b></a>(byte[])
<dd>This method encodes the given byte[] using the base64-encoding
specified in RFC-2045 (Section 6.8).
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#base64Encode(java.lang.String)"><b>base64Encode</b></a>(String)
<dd>This method encodes the given string using the base64-encoding
specified in RFC-2045 (Section 6.8).
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#chunkedDecode(java.io.InputStream)"><b>chunkedDecode</b></a>(InputStream)
<dd>Decodes chunked data.
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#chunkedEncode(byte[], int, int, HTTPClient.NVPair[], boolean)"><b>chunkedEncode</b></a>(byte[], int, int, NVPair[], boolean)
<dd>Encodes data used the chunked encoding.
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#chunkedEncode(byte[], HTTPClient.NVPair[], boolean)"><b>chunkedEncode</b></a>(byte[], NVPair[], boolean)
<dd>Encodes data used the chunked encoding.
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#mpFormDataDecode(byte[], java.lang.String, java.lang.String)"><b>mpFormDataDecode</b></a>(byte[], String, String)
<dd>This method decodes a multipart/form-data encoded string.
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#mpFormDataEncode(HTTPClient.NVPair[], HTTPClient.NVPair[], HTTPClient.NVPair[])"><b>mpFormDataEncode</b></a>(NVPair[], NVPair[], NVPair[])
<dd>This method encodes name/value pairs and files into a byte array
using the multipart/form-data encoding.
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#nv2query(HTTPClient.NVPair[])"><b>nv2query</b></a>(NVPair[])
<dd>Turns an array of name/value pairs into the string
"name1=value1&name2=value2&name3=value3".
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#query2nv(java.lang.String)"><b>query2nv</b></a>(String)
<dd>Turns a string of the form "name1=value1&name2=value2&name3=value3"
into an array of name/value pairs.
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#quotedPrintableDecode(java.lang.String)"><b>quotedPrintableDecode</b></a>(String)
<dd>This method does a quoted-printable decoding of the given string
according to RFC-2045 (Section 6.7).
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#quotedPrintableEncode(java.lang.String)"><b>quotedPrintableEncode</b></a>(String)
<dd>This method does a quoted-printable encoding of the given string
according to RFC-2045 (Section 6.7).
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#URLDecode(java.lang.String)"><b>URLDecode</b></a>(String)
<dd>This method decodes the given urlencoded string.
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#URLEncode(java.lang.String)"><b>URLEncode</b></a>(String)
<dd>This method urlencodes the given string.
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#uudecode(char[])"><b>uudecode</b></a>(char[])
<dd>This method decodes the given uuencoded char[].
<dt><img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
<a href="#uuencode(byte[])"><b>uuencode</b></a>(byte[])
<dd>This method encodes the given byte[] using the unix uuencode
encding.
</dl>
<a name="methods"></a><h2>
<img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="base64Encode"></a><a name="base64Encode(java.lang.String)"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>base64Encode</b>
<pre>
public static final String base64Encode(String str)</pre>
<dl>
<dd>This method encodes the given string using the base64-encoding
specified in RFC-2045 (Section 6.8). It's used for example in the
"Basic" authorization scheme.
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>str - the string
<dt><b>Returns:</b>
<dd>the base64-encoded <var>str</var></dl>
</dd>
</dl>
<a name="base64Encode"></a><a name="base64Encode(byte[])"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>base64Encode</b>
<pre>
public static final byte[] base64Encode(byte[] data)</pre>
<dl>
<dd>This method encodes the given byte[] using the base64-encoding
specified in RFC-2045 (Section 6.8).
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>data - the data
<dt><b>Returns:</b>
<dd>the base64-encoded <var>data</var></dl>
</dd>
</dl>
<a name="base64Decode"></a><a name="base64Decode(java.lang.String)"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>base64Decode</b>
<pre>
public static final String base64Decode(String str)</pre>
<dl>
<dd>This method decodes the given string using the base64-encoding
specified in RFC-2045 (Section 6.8).
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>str - the base64-encoded string.
<dt><b>Returns:</b>
<dd>the decoded <var>str</var>.</dl>
</dd>
</dl>
<a name="base64Decode"></a><a name="base64Decode(byte[])"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>base64Decode</b>
<pre>
public static final byte[] base64Decode(byte[] data)</pre>
<dl>
<dd>This method decodes the given byte[] using the base64-encoding
specified in RFC-2045 (Section 6.8).
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>data - the base64-encoded data.
<dt><b>Returns:</b>
<dd>the decoded <var>data</var>.</dl>
</dd>
</dl>
<a name="uuencode"></a><a name="uuencode(byte[])"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>uuencode</b>
<pre>
public static final char[] uuencode(byte[] data)</pre>
<dl>
<dd>This method encodes the given byte[] using the unix uuencode
encding. The output is split into lines starting with the encoded
number of encoded octets in the line and ending with a newline.
No line is longer than 45 octets (60 characters), not including
length and newline.
<P><em>Note:</em> just the raw data is encoded; no 'begin' and 'end'
lines are added as is done by the unix <code>uuencode</code> utility.
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>data - the data
<dt><b>Returns:</b>
<dd>the uuencoded <var>data</var></dl>
</dd>
</dl>
<a name="uudecode"></a><a name="uudecode(char[])"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>uudecode</b>
<pre>
public static final byte[] uudecode(char[] data)</pre>
<dl>
<dd>This method decodes the given uuencoded char[].
<P><em>Note:</em> just the actual data is decoded; any 'begin' and
'end' lines as generated by unix <code>uuencode</code> utility must
not be included.
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>data - the uuencode-encoded data.
<dt><b>Returns:</b>
<dd>the decoded <var>data</var>.</dl>
</dd>
</dl>
<a name="quotedPrintableEncode"></a><a name="quotedPrintableEncode(java.lang.String)"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>quotedPrintableEncode</b>
<pre>
public static final String quotedPrintableEncode(String str)</pre>
<dl>
<dd>This method does a quoted-printable encoding of the given string
according to RFC-2045 (Section 6.7). <em>Note:</em> this assumes
8-bit characters.
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>str - the string
<dt><b>Returns:</b>
<dd>the quoted-printable encoded string</dl>
</dd>
</dl>
<a name="quotedPrintableDecode"></a><a name="quotedPrintableDecode(java.lang.String)"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>quotedPrintableDecode</b>
<pre>
public static final String quotedPrintableDecode(String str) throws <a href="HTTPClient.ParseException.html">ParseException</a></pre>
<dl>
<dd>This method does a quoted-printable decoding of the given string
according to RFC-2045 (Section 6.7). <em>Note:</em> this method
expects the whole message in one chunk, not line by line.
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>str - the message
<dt><b>Returns:</b>
<dd>the decoded message<dt><b>Throws:</b>
<a href="HTTPClient.ParseException.html">ParseException</a><dd>If a '=' is not followed by a valid
2-digit hex number or '\r\n'.</dl>
</dd>
</dl>
<a name="URLEncode"></a><a name="URLEncode(java.lang.String)"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>URLEncode</b>
<pre>
public static final String URLEncode(String str)</pre>
<dl>
<dd>This method urlencodes the given string. This method is here for
symmetry reasons and just calls java.net.URLEncoder.encode().
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>str - the string
<dt><b>Returns:</b>
<dd>the url-encoded string</dl>
</dd>
</dl>
<a name="URLDecode"></a><a name="URLDecode(java.lang.String)"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>URLDecode</b>
<pre>
public static final String URLDecode(String str) throws <a href="HTTPClient.ParseException.html">ParseException</a></pre>
<dl>
<dd>This method decodes the given urlencoded string.
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>str - the url-encoded string
<dt><b>Returns:</b>
<dd>the decoded string<dt><b>Throws:</b>
<a href="HTTPClient.ParseException.html">ParseException</a><dd>If a '%' is not followed by a valid
2-digit hex number.</dl>
</dd>
</dl>
<a name="mpFormDataDecode"></a><a name="mpFormDataDecode(byte[], java.lang.String, java.lang.String)"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>mpFormDataDecode</b>
<pre>
public static final <a href="HTTPClient.NVPair.html">NVPair</a>[] mpFormDataDecode(byte[] data,
                                              String cont_type,
                                              String dir) throws IOException, <a href="HTTPClient.ParseException.html">ParseException</a></pre>
<dl>
<dd>This method decodes a multipart/form-data encoded string. The boundary
is parsed from the <var>cont_type</var> parameter, which must be of the
form 'multipart/form-data; boundary=...'. Any encoded files are created
in the directory specified by <var>dir</var> using the encoded filename.
<P><em>Note:</em> Does not handle nested encodings (yet).
<P>Examples: If you're receiving a multipart/form-data encoded response
from a server you could use something like:
<PRE>
    NVPair[] opts = Codecs.mpFormDataDecode(resp.getData(),
					    resp.getHeader("Content-type"), ".");
</PRE>
If you're using this in a Servlet to decode the body of a request from
a client you could use something like:
<PRE>
    byte[] body = new byte[req.getContentLength()];
    new DataInputStream(req.getInputStream()).readFully(body);
    NVPair[] opts = Codecs.mpFormDataDecode(body, req.getContentType(), ".");
</PRE>
Assuming the data received looked something like:
<PRE>
-----------------------------114975832116442893661388290519
Content-Disposition: form-data; name="option"
&nbsp;
doit
-----------------------------114975832116442893661388290519
Content-Disposition: form-data; name="comment"; filename="comment.txt"
&nbsp;
Gnus and Gnats are not Gnomes.
-----------------------------114975832116442893661388290519--
</PRE>
you would get one file called <VAR>comment.txt</VAR> in the current
directory, and opts would contain two elements: {"option", "doit"}
and {"comment", "comment.txt"}
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>data - the form-data to decode.
<dd>cont_type - the content type header (must contain the
boundary string).
<dd>dir - the directory to create the files in.
<dt><b>Returns:</b>
<dd>an array of name/value pairs, one for each part;
the name is the 'name' attribute given in the
Content-Disposition header; the value is either
the name of the file if a filename attribute was
found, or the contents of the part.<dt><b>Throws:</b>
IOException<dd>If any file operation fails.<dt><b>Throws:</b>
<a href="HTTPClient.ParseException.html">ParseException</a><dd>If an error during parsing occurs.</dl>
</dd>
</dl>
<a name="mpFormDataEncode"></a><a name="mpFormDataEncode(HTTPClient.NVPair[], HTTPClient.NVPair[], HTTPClient.NVPair[])"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>mpFormDataEncode</b>
<pre>
public static final byte[] mpFormDataEncode(<a href="HTTPClient.NVPair.html">NVPair</a>[] opts,
                                            <a href="HTTPClient.NVPair.html">NVPair</a>[] files,
                                            <a href="HTTPClient.NVPair.html">NVPair</a>[] cont_type) throws IOException</pre>
<dl>
<dd>This method encodes name/value pairs and files into a byte array
using the multipart/form-data encoding. The boundary is returned
as part of <var>cont_type</var>.
<BR>Example:
<PRE>
    NVPair[] opts = { new NVPair("option", "doit") };
    NVPair[] file = { new NVPair("comment", "comment.txt") };
    NVPair[] hdrs = new NVPair[1];
    byte[]   data = Codecs.mpFormDataEncode(opts, file, hdrs);
    con.Post("/cgi-bin/handle-it", data, hdrs);
</PRE>
<VAR>data</VAR> will look something like the following:
<PRE>
-----------------------------114975832116442893661388290519
Content-Disposition: form-data; name="option"
&nbsp;
doit
-----------------------------114975832116442893661388290519
Content-Disposition: form-data; name="comment"; filename="comment.txt"
&nbsp;
Gnus and Gnats are not Gnomes.
-----------------------------114975832116442893661388290519--
</PRE>
where the "Gnus and Gnats ..." is the contents of the file
<VAR>comment.txt</VAR> in the current directory.
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>opts - the simple form-data to encode (may be null);
for each NVPair the name refers to the 'name'
attribute to be used in the header of the part,
and the value is contents of the part.
<dd>files - the files to encode (may be null); for each
NVPair the name refers to the 'name' attribute
to be used in the header of the part, and the
value is the actual filename (the file will be
read and it's contents put in the body of that
part).
<dd>cont_type - this returns a new NVPair in the 0'th element
which contains
name = "Content-Type",
value = "multipart/form-data; boundary=..."
(the reason this parameter is an array is
because a) that's the only way to simulate
pass-by-reference and b) you need an array for
the headers parameter to the Post() or Put()
anyway).
<dt><b>Returns:</b>
<dd>an encoded byte array containing all the opts
and files.<dt><b>Throws:</b>
IOException<dd>If any file operation fails.</dl>
</dd>
</dl>
<a name="nv2query"></a><a name="nv2query(HTTPClient.NVPair[])"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>nv2query</b>
<pre>
public static final String nv2query(<a href="HTTPClient.NVPair.html">NVPair</a>[] pairs)</pre>
<dl>
<dd>Turns an array of name/value pairs into the string
"name1=value1&name2=value2&name3=value3". The names and values are
first urlencoded. This is the form in which form-data is passed to
a cgi script.
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>pairs - the array of name/value pairs
<dt><b>Returns:</b>
<dd>a string containg the encoded name/value pairs</dl>
</dd>
</dl>
<a name="query2nv"></a><a name="query2nv(java.lang.String)"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>query2nv</b>
<pre>
public static final <a href="HTTPClient.NVPair.html">NVPair</a>[] query2nv(String query) throws <a href="HTTPClient.ParseException.html">ParseException</a></pre>
<dl>
<dd>Turns a string of the form "name1=value1&name2=value2&name3=value3"
into an array of name/value pairs. The names and values are
urldecoded. The query string is in the form in which form-data is
received in a cgi script.
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>query - the query string containing the encoded name/value pairs
<dt><b>Returns:</b>
<dd>an array of NVPairs<dt><b>Throws:</b>
<a href="HTTPClient.ParseException.html">ParseException</a><dd>If the '=' is missing in any field, or if
the urldecoding of the name or value fails</dl>
</dd>
</dl>
<a name="chunkedEncode"></a><a name="chunkedEncode(byte[], HTTPClient.NVPair[], boolean)"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>chunkedEncode</b>
<pre>
public static final byte[] chunkedEncode(byte[] data,
                                         <a href="HTTPClient.NVPair.html">NVPair</a>[] ftrs,
                                         boolean last)</pre>
<dl>
<dd>Encodes data used the chunked encoding. <var>last</var> signales if
this is the last chunk, in which case the appropriate footer is
generated.
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>data - the data to be encoded; may be null.
<dd>ftrs - optional headers to include in the footer (ignored if
not last); may be null.
<dd>last - whether this is the last chunk.
<dt><b>Returns:</b>
<dd>an array of bytes containing the chunk</dl>
</dd>
</dl>
<a name="chunkedEncode"></a><a name="chunkedEncode(byte[], int, int, HTTPClient.NVPair[], boolean)"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>chunkedEncode</b>
<pre>
public static final byte[] chunkedEncode(byte[] data,
                                         int off,
                                         int len,
                                         <a href="HTTPClient.NVPair.html">NVPair</a>[] ftrs,
                                         boolean last)</pre>
<dl>
<dd>Encodes data used the chunked encoding. <var>last</var> signales if
this is the last chunk, in which case the appropriate footer is
generated.
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>data - the data to be encoded; may be null.
<dd>off - an offset into the <var>data</var>
<dd>len - the number of bytes to take from <var>data</var>
<dd>ftrs - optional headers to include in the footer (ignored if
not last); may be null.
<dd>last - whether this is the last chunk.
<dt><b>Returns:</b>
<dd>an array of bytes containing the chunk</dl>
</dd>
</dl>
<a name="chunkedDecode"></a><a name="chunkedDecode(java.io.InputStream)"><img src="images/green-ball.gif" width=12 height=12 alt=" o ">
</a><b>chunkedDecode</b>
<pre>
public static final Object chunkedDecode(InputStream input) throws <a href="HTTPClient.ParseException.html">ParseException</a>, IOException</pre>
<dl>
<dd>Decodes chunked data. The chunks are read from an InputStream, which
is assumed to be correctly positioned. Use 'xxx instanceof byte[]'
and 'xxx instanceof NVPair[]' to determine if this was data or the
last chunk.
<p>
<dd><dl>
<dt><b>Parameters:</b>
<dd>input - the stream from which to read the next chunk.
<dt><b>Returns:</b>
<dd>If this was a data chunk then it returns a byte[]; else
it's the footer and it returns a NVPair[] containing the
footers.<dt><b>Throws:</b>
<a href="HTTPClient.ParseException.html">ParseException</a><dd>If any exception during parsing occured.<dt><b>Throws:</b>
IOException<dd>If any exception during reading occured.</dl>
</dd>
</dl>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-HTTPClient.html">This Package</a>  <a href="HTTPClient.AuthorizationInfo.html">Previous</a>  <a href="HTTPClient.Cookie.html">Next</a>  <a href="Index.html">Index</a>  </pre>
</body>
</html>
