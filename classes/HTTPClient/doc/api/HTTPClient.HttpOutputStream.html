<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Sun Jun 20 15:32:32 PDT 1999 -->
<title>
  Class HTTPClient.HttpOutputStream
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-HTTPClient.html">This Package</a>  <a href="HTTPClient.HttpHeaderElement.html#_top_">Previous</a>  <a href="HTTPClient.HttpURLConnection.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class HTTPClient.HttpOutputStream
</h1>
<pre>
java.lang.Object
   |
   +----java.io.OutputStream
           |
           +----HTTPClient.HttpOutputStream
</pre>
<hr>
<dl>
  <dt> public class <b>HttpOutputStream</b>
  <dt> extends OutputStream
  <dt> implements GlobalConstants
</dl>
This class provides an output stream for requests. The stream must first
 be associated with a request before it may be used; this is done by
 passing it to one of the request methods in HTTPConnection. Example:
 <PRE>
    OutputStream out = new HttpOutputStream(12345);
    rsp = con.Post("/cgi-bin/my_cgi", out);
    out.write(...);
    out.close();
    if (rsp.getStatusCode() >= 300)
        ...
 </PRE>
 <P>There are two constructors for this class, one taking a length parameter,
 and one without any parameters. If the stream is created with a length
 then the request will be sent with the corresponding Content-length header
 and anything written to the stream will be written on the socket immediately.
 This is the preferred way. If the stream is created without a length then
 one of two things will happen: if, at the time of the request, the server
 is known to understand HTTP/1.1 then each write() will send the data
 immediately using the chunked encoding. If, however, either the server
 version is unknown (because this is first request to that server) or the
 server only understands HTTP/1.0 then all data will be written to a buffer
 first, and only when the stream is closed will the request be sent.
 <P>Another reason that using the <var>HttpOutputStream(length)</var>
 constructor is recommended over the <var>HttpOutputStream()</var> one is
 that some HTTP/1.1 servers do not allow the chunked transfer encoding to
 be used when POSTing to a cgi script. This is because the way the cgi API
 is defined the cgi script expects a Content-length environment variable.
 If the data is sent using the chunked transfer encoding however, then the
 server would have to buffer all the data before invoking the cgi so that
 this variable could be set correctly. Not all servers are willing to do
 this.
 <P>If you cannot use the <var>HttpOutputStream(length)</var> constructor and
 are having problems sending requests (usually a 411 response) then you can
 try setting the system property <var>HTTPClient.dontChunkRequests</var> to
 <var>true</var> (this needs to be done either on the command line or
 somewhere in the code before the HTTPConnection is first accessed). This
 will prevent the client from using the chunked encoding in this case and
 will cause the HttpOutputStream to buffer all the data instead, sending it
 only when close() is invoked.
 <P>The behaviour of a request sent with an output stream may differ from
 that of a request sent with a data parameter. The reason for this is that
 the various modules cannot resend a request which used an output stream.
 Therefore such things as authorization and retrying of requests won't be
 done by the HTTPClient for such requests.
<p>
<dl>
  <dt> <b>Version:</b>
  <dd> 0.3-2  18/06/1999
  <dt> <b>Author:</b>
  <dd> Ronald Tschalär
</dl>
<hr>
<a name="index"></a>
<h2>
  <img src="images/constructor-index.gif" width=275 height=38 alt="Constructor Index">
</h2>
<dl>
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#HttpOutputStream()"><b>HttpOutputStream</b></a>()
  <dd>  Creates an output stream of unspecified length.
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#HttpOutputStream(int)"><b>HttpOutputStream</b></a>(int)
  <dd>  This creates an output stream which will take <var>length</var> bytes
 of data.
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#close()"><b>close</b></a>()
  <dd>  Closes the stream and causes the data to be sent if it has not already
 been done so.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getLength()"><b>getLength</b></a>()
  <dd>  Returns the number of bytes this stream is willing to accept, or -1
 if it is unbounded.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getTrailers()"><b>getTrailers</b></a>()
  <dd>  Gets the trailers which were set with <code>setTrailers()</code>.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#setTrailers(HTTPClient.NVPair[])"><b>setTrailers</b></a>(NVPair[])
  <dd>  Sets the trailers to be sent if the output is sent with the
 chunked transfer encoding.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#toString()"><b>toString</b></a>()
  <dd>  produces a string describing this stream.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#write(byte[], int, int)"><b>write</b></a>(byte[], int, int)
  <dd>  Writes an array of bytes on the stream.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#write(int)"><b>write</b></a>(int)
  <dd>  Writes a single byte on the stream.
</dl>
<a name="constructors"></a>
<h2>
  <img src="images/constructors.gif" width=231 height=38 alt="Constructors">
</h2>
<a name="HttpOutputStream"></a>
<a name="HttpOutputStream()"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>HttpOutputStream</b>
<pre>
 public HttpOutputStream()
</pre>
<dl>
  <dd> Creates an output stream of unspecified length. Note that it is
 <strong>highly</strong> recommended that this constructor be avoided
 where possible and <code>HttpOutputStream(int)</code> used instead.
<p>
  <dd><dl>
    <dt> <b>See Also:</b>
    <dd> <a href="#HttpOutputStream(int)">HttpOutputStream</a>
  </dl></dd>
</dl>
<a name="HttpOutputStream(int)"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>HttpOutputStream</b>
<pre>
 public HttpOutputStream(int length)
</pre>
<dl>
  <dd> This creates an output stream which will take <var>length</var> bytes
 of data.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> length - the number of bytes which will be sent over this stream
  </dl></dd>
</dl>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="getLength()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getLength"><b>getLength</b></a>
<pre>
 public int getLength()
</pre>
<dl>
  <dd> Returns the number of bytes this stream is willing to accept, or -1
 if it is unbounded.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> the number of bytes
  </dl></dd>
</dl>
<a name="getTrailers()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getTrailers"><b>getTrailers</b></a>
<pre>
 public <a href="HTTPClient.NVPair.html#_top_">NVPair</a>[] getTrailers()
</pre>
<dl>
  <dd> Gets the trailers which were set with <code>setTrailers()</code>.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> an array of header fields
    <dt> <b>See Also:</b>
    <dd> <a href="#setTrailers(NVPair[])">setTrailers</a>
  </dl></dd>
</dl>
<a name="setTrailers(HTTPClient.NVPair[])"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="setTrailers"><b>setTrailers</b></a>
<pre>
 public void setTrailers(<a href="HTTPClient.NVPair.html#_top_">NVPair</a> trailers[])
</pre>
<dl>
  <dd> Sets the trailers to be sent if the output is sent with the
 chunked transfer encoding. These must be set before the output
 stream is closed for them to be sent.
 <P>Any trailers set here <strong>should</strong> be mentioned
 in a <var>Trailer</var> header in the request (see section 14.40
 of draft-ietf-http-v11-spec-rev-06.txt).
 <P>This method (and its related <code>getTrailers()</code>)) are
 in this class and not in <var>Request</var> because setting
 trailers is something an application may want to do, not only
 modules.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> trailers - an array of header fields
  </dl></dd>
</dl>
<a name="write(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="write"><b>write</b></a>
<pre>
 public void write(int b) throws IOException, IllegalAccessError
</pre>
<dl>
  <dd> Writes a single byte on the stream. It is subject to the same rules
 as <code>write(byte[], int, int)</code>.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> b - the byte to write
    <dt> <b>Throws:</b> IOException
    <dd> if any exception is thrown by the socket
    <dt> <b>Overrides:</b>
    <dd> <a href="http://java.sun.com/products/jdk/1.1/docs/api/java.io.OutputStream.html#write(int)">write</a> in class OutputStream
    <dt> <b>See Also:</b>
    <dd> <a href="#write(byte[], int, int)">write</a>
  </dl></dd>
</dl>
<a name="write(byte[], int, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="write"><b>write</b></a>
<pre>
 public synchronized void write(byte buf[],
                                int off,
                                int len) throws IOException, IllegalAccessError
</pre>
<dl>
  <dd> Writes an array of bytes on the stream. This method may not be used
 until this stream has been passed to one of the methods in
 HTTPConnection (i.e. until it has been associated with a request).
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> buf - an array containing the data to write
    <dd> off - the offset of the data whithin the buffer
    <dd> len - the number bytes (starting at <var>off</var>) to write
    <dt> <b>Throws:</b> IOException
    <dd> if any exception is thrown by the socket, or
            if writing <var>len</var> bytes would cause more bytes to
            be written than this stream is willing to accept.
    <dt> <b>Throws:</b> IllegalAccessError
    <dd> if this stream has not been associated
            with a request yet
    <dt> <b>Overrides:</b>
    <dd> <a href="http://java.sun.com/products/jdk/1.1/docs/api/java.io.OutputStream.html#write(byte[], int, int)">write</a> in class OutputStream
  </dl></dd>
</dl>
<a name="close()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="close"><b>close</b></a>
<pre>
 public synchronized void close() throws IOException, IllegalAccessError
</pre>
<dl>
  <dd> Closes the stream and causes the data to be sent if it has not already
 been done so. This method <strong>must</strong> be invoked when all
 data has been written.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> IOException
    <dd> if any exception is thrown by the underlying
            socket, or if too few bytes were written.
    <dt> <b>Throws:</b> IllegalAccessError
    <dd> if this stream has not been associated
            with a request yet.
    <dt> <b>Overrides:</b>
    <dd> <a href="http://java.sun.com/products/jdk/1.1/docs/api/java.io.OutputStream.html#close()">close</a> in class OutputStream
  </dl></dd>
</dl>
<a name="toString()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="toString"><b>toString</b></a>
<pre>
 public String toString()
</pre>
<dl>
  <dd> produces a string describing this stream.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> a string containing the name and the length
    <dt> <b>Overrides:</b>
    <dd> <a href="http://java.sun.com/products/jdk/1.1/docs/api/java.lang.Object.html#toString()">toString</a> in class Object
  </dl></dd>
</dl>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-HTTPClient.html">This Package</a>  <a href="HTTPClient.HttpHeaderElement.html#_top_">Previous</a>  <a href="HTTPClient.HttpURLConnection.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
