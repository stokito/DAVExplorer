
<HTML>

<HEAD>
<TITLE>Advanced HTTPClient Info</TITLE>
<LINK REV="made"     HREF="mailto:ronald@innovation.ch">
<LINK REL="Previous" HREF="getting_started.html">
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<H1>Advanced HTTPClient Info</H1>


<H2>Contents</H2>

<UL>
<LI><A HREF="#proxies">Proxies</A>
<LI><A HREF="#timeouts">Timeouts</A>
<LI><A HREF="#contexts">Contexts</A>
<LI><A HREF="#pers_con">Persistent Connections (Keep-Alive's)</A>
<LI><A HREF="#pipelining">Pipelining</A>
<LI><A HREF="#prot_vers">Protocol Version</A>
<LI><A HREF="#modules">Modules</A>
<LI><A HREF="#properties">Properties recognized by HTTPClient</A>
<LI><A HREF="#headers">HTTP Headers</A>
</UL>


<H2><A NAME="proxies">Proxies</A></H2>

<P>Support for proxies (including SOCKS) is fully implemented. However,
using proxies in Applets is subject to a number of security restrictions
(see <A HREF="security.html">security</A> for more information on the
various security policies and the consequences that arise from them).
If you are using an http proxy then use the <A
HREF="api/HTTPClient.HTTPConnection.html#setProxyServer(java.lang.String, int)">HTTPConnection.setProxyServer()</A>
method to set the default proxy for all connections, and <A
HREF="api/HTTPClient.HTTPConnection.html#setCurrentProxy(java.lang.String, int)">HTTPConnection.setCurrentProxy()</A>
to set a proxy for the current connection only. You can also manipulate a
list of hosts for which no proxy is to be used with the methods <A
HREF="api/HTTPClient.HTTPConnection.html#dontProxyFor(java.lang.String)">HTTPConnection.dontProxyFor()</A>
and <A
HREF="api/HTTPClient.HTTPConnection.html#doProxyFor(java.lang.String)">HTTPConnection.doProxyFor()</A>.

<P>If you are using SOCKS then the method to use is <A
HREF="api/HTTPClient.HTTPConnection.html#setSocksServer(java.lang.String)">setSocksServer()</A>.
Note that both an http proxy and a SOCKS proxy can be set at the same
time, in which case a request is sent via the SOCKS server to the proxy
server, which in turn relays the request to the desired destination.

<P>Some proxies will proxy for protocols other than http using http to
contact the proxy itself. If you have such a proxy then you can use the
HTTPClient to do requests for other protocols through the proxy. To do
this you need to create an <var>HTTPConnection</var> to the proxy
itself (i.e. <em>don't</em> use <A
HREF="api/HTTPClient.HTTPConnection.html#setCurrentProxy(java.lang.String, int)">setCurrentProxy()</A>
or <A
HREF="api/HTTPClient.HTTPConnection.html#setProxyServer(java.lang.String, int)">setProxyServer()</A>)
and specify the full URL of the file/article/whatever in the Get(),
Put(), etc. Example:  if you want to retrieve the file
<var>/pub/README</var> via ftp from <var>rtfm.mit.edu</var> then you
could use something like:
<PRE>
    HTTPConnection proxy = new HTTPConnection("my.proxy.dom", 8000);
    HTTPResponse   resp  = proxy.Get("ftp://rtfm.mit.edu/pub/README");
    ...
</PRE>


<H2><A NAME="timeouts">Timeouts</A></H2>

<P>Sometimes one doesn't want to wait (almost) forever until a connection
is established to the server or until the server answers. In this case a
timeout can be set using the methods <A
HREF="api/HTTPClient.HTTPConnection.html#setDefaultTimeout(int)">HTTPConnection.setDefaultTimeout()</A>
and <A
HREF="api/HTTPClient.HTTPConnection.html#setTimeout(int)">HTTPConnection.setTimeout()</A>.
Setting a timeout will cause the client to limit the time it will spend
trying to get the hosts IP-address and establishing a connection with the
server. If this is running under JDK 1.1 or later it will also set the
timeout on the socket while reading the response headers. The timeout is
always disabled while reading the response body. The rationale for this is
that otherwise I'd have to make all the input streams (which may be pushed
onto the response input stream) reentrant, and this would include writing
my own versions of GZIPInputStream etc.


<H2><A NAME="contexts">Contexts</A></H2>

<P>There has been the desire to run multiple independent clients within
one application. This was previously hindered by the fact that the list
of authorization info was shared by all instances of
<var>HTTPConnection</var>, resulting in all clients having to use the
same username and password. Starting with V0.3 you can set a context
(<A
HREF="api/HTTPClient.HTTPConnection.html#setContext(java.lang.Object)">HTTPConnection.setContext()</A>)
for each <var>HTTPConnection</var>.  Each <A HREF="#modules">module</A>
which keeps information on behalf of the application (such as the
cookie module, the authorization module and the redirection module)
then uses a separate list for each context. In this way only instances
of <var>HTTPConnection</var> using the same context will share
information.

<P>If no context is set a default context is used which is the same for
all <var>HTTPConnection</var>s. Therefore applications which don't need
this feature can just ignore it and they will behave as before.


<H2><A NAME="pers_con">Persistent Connections (Keep-Alive's)</A></H2>

<P>The Hypertext Transfer Protocol originally allowed only one request per
TCP connection. However, establishing a TCP connection is fairly expensive
time wise, so that some implementors of HTTP/1.0 added so called
<var>Keep-Alive's</var> to keep a connection open after a request was
completed and to allow further requests to be made over that connection.
Unfortunately, this was not well defined and is broken in the face of
proxies. HTTP/1.1 defines persistent connections correctly and even
makes them the default.

<P>The HTTPClient will by default try to keep a connection alive for
as many requests as possible, both when talking to HTTP/1.0 and
HTTP/1.1 servers. To disable persistent connections you can
specify a <var>Connection</var> header with the value <var>close</var>.
Example:

<pre>
    NVPair[] def_hdrs = { new NVPair("Connection", "close") };
    con.setDefaultHeaders(def_hdrs);
</pre>

<P>This will disable persistent connections for all future request
(unless overridden by a connection header on the request method call).

<P>Keeping the connection to the server open after a request is fine as
long as another request follows within a short period of time. However
when you are done you should let the library know by passing the above
<code>Connection: close</code> header with the last request.
Furthermore, to limit the length of time the connection will be held
open a timer is started after each request which will close the
connection if no further requests arrive within the next 60 seconds.

<P>Note that most of this is transparent as far as the functioning of
the requests is concerned; the only differences you will notice is in
the time required for a request to be sent. Also note that persistent
connections are only done within the context of a given instance of
<var>HTTPConnection</var>; so if you create two instances both pointing
at the same server then they will create separate connections to the
server.


<H3><A NAME="socket-close">Closing of Sockets</A></H3>

<P>A socket is closed when one of the five following conditions occurs:
<UL>
<LI> if an exception occurs during read or write.
<LI> if a response is marked for close but no responses are outstanding
     (e.g. due to a timeout).
<LI> when a response stream which is marked for close is closed.
<LI> if all response streams up until and including the marked for close
     stream have been closed.
<LI> if the stream demultiplexor is finalized.
</UL>

<P>Responses are marked for close whenever the client determines that the
connection should not be kept open past the end of this response. This
includes the connection timing out, the server sending a
<code>Connection: close</code> (in the case of an HTTP/1.1 server) or not
sending a <code>Connection: keep-alive</code> (in the case of an HTTP/1.0
server), the response having no Content-length and no self-delimiting
body, or the receipt of certain error status codes.


<H2><A NAME="pipelining">Pipelining</A></H2>

<P>If the connection is kept open across request then the request may be
pipelined. Pipelining here means that a new request is sent before the
response to a previous request is received. It is obvious that this may
speed up requests, so HTTPClient supports pipelining (at the expense of
some extra code to keep track of the outstanding requests).

<P>In spite of all the possible pipelining going on underneath, the
programming model still stays simple: for every request you send you
get a reponse back which contains the headers and data of the servers
response. Now with pipelining the fields in the reponse aren't
necessarily filled yet (i.e. the actual response headers and data
haven't been read off the net), but the first call to any method in the
reponse (e.g. a <var>getStatusCode()</var>) will wait till the reponse
has actually been read and parsed. Also any previous requests will be
forced to read their responses if they have not already done so (so
e.g.  if you send two consecutive requests and receive responses
<var>r1</var> and <var>r2</var>, calling
<code>r2.getHeader("Content-type")</code> will first force the complete
response <var>r1</var> to be read before reading the response
<var>r2</var>). All this should be completely transparent, except for
the fact that invoking a method on one response may sometimes take a few
seconds to complete, while the same method on a different response will
return immediately with the desired info.


<H2><A NAME="prot_vers">Protocol Version</A></H2>

<P>The request protocol version sent is always HTTP/1.1, except in a
few circumstances when a broken server is encountered, in which case
the version sent reverts to HTTP/1.0. An HTTP/0.9 request is never
sent.

<P>The protocol version returned by the server is used to select
between different mechanisms for persistent connections. If the server
advertises itself as being HTTP/1.1 compliant then HTTP/1.1 persistent
connections are used; otherwise HTTP/1.0 keep-alives are used (the
difference is the tokens used in the Connection header for signaling
persistence and the end of a connection). Apart from this, the only
other distinction made between talking to an HTTP/1.0 or an HTTP/1.1
server is in how request are automatically retried (retried requests
with a body need to use slighly different mechanisms for determining
how long to wait after sending the headers, before sending the body).


<H2><A NAME="modules">Modules</A></H2>

<P>Starting with Version 0.3 the HTTPClient uses modules for a number of
its functions. Each connection has a list of modules. When a request
method is invoked the request is first assembled into a <A
HREF="api/HTTPClient.Request.html">Request</A> instance. Then the
request handler of each module is invoked in turn with this request. This
handler may modify the request (such as add headers) or even generate a
response directly (such as a cache might do). Only after all handlers
have been invoked (and none of them generated a response) is the request
actually sent over the wire.  Similarly, when a response is read the
response handlers in each module are invoked in turn. They may do certain
things based on the status code (such as the redirection module) or the
headers (such as the cookie module), modify the response, or even
generate a new request (such as in the redirection and authentication
modules). If a new request is generated the process starts from the top.

<P>The use of modules allows additional functionality to be easily added
without having to modify the core code. It also allows for the easy
enabling and disabling of various functions. The currently supplied
modules are the <var>AuthenticationModule</var>, the
<var>RedirectionModule</var>, the <var>ContentEncodingModule</var>, the
<var>TransferEncodingModule</var>, the <var>CookieModule</var>, the
<var>ContentMD5Module</var>, the <var>RetryModule</var> and the
<var>DefaultModule</var>. These are explained in more detail further
down.

<P>Modules can be dynamically added and removed to tailor the request
and response processing desired. The methods <A
HREF="api/HTTPClient.HTTPConnection.html#addDefaultModule(java.lang.Class, int)">HTTPConnection.addDefaultModule()</A>,
<A
HREF="api/HTTPClient.HTTPConnection.html#removeDefaultModule(java.lang.Class)">HTTPConnection.removeDefaultModule()</A>
and <A
HREF="api/HTTPClient.HTTPConnection.html#getDefaultModules()">HTTPConnection.getDefaultModules()</A>
manipulate and return the list of default modules which is used when a
new <A HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>
is created. Similarly, the methods <A
HREF="api/HTTPClient.HTTPConnection.html#addModule(java.lang.Class, int)">HTTPConnection.addModule()</A>,
<A
HREF="api/HTTPClient.HTTPConnection.html#removeModule(java.lang.Class)">HTTPConnection.removeModule()</A>
and <A
HREF="api/HTTPClient.HTTPConnection.html#getModules()">HTTPConnection.getModules()</A>
manipulate and return the list of current modules for an connection.

<P>The default list of modules is initialized from the property
<var>HTTPClient.Modules</var>. This property must be a "|" separated list
of class names. If this property is not set it defaults to all the classes
listed below. Normally if during class initialization any module in the
list does not exist or cannot be instantiated then an Error is thrown.
However, if this is being used in an Applet then the error is supressed.
This way Applets can limit the modules loaded over the net by simply not
providing them (remember, they can't set properties due to security
restrictions).

<P>You may create your own modules and add them using the above methods.
Any module you write must implement the <A
HREF="api/HTTPClient.HTTPClientModule.html">HTTPClientModule</A>
interface. See the API docs more info. <strong>Note:</strong> this
interface may change. If you write a module and find the interface
insufficient or difficult, please contact me. Also, if you write a module
which you think might be of general usefulness and would like to make it
freely available, let me know.

<P>Here is a short description of each module.


<H3>AuthorizationModule</H3>

<P>Authorization briefly described in <A HREF="getting_started.html#auth">
Getting Started</A>. As mentioned, this module will handle both server and
proxy authorization requests (status codes 401 and 407). In addition to the
'Basic' and 'Digest' authorization schemes, the AuthorizationModule can be
made to handle other schemes as well, so long as they are not "too exotic"
(i.e. they follow the simple challenge-response mechanism outlined in the
http specs); this is done by setting your own <A
HREF="api/HTTPClient.AuthorizationHandler.html">AuthorizationHandler</A>.
Of course, if you need to something more sophisticated you can always plug
in your own auth module.

<P>When confronted with an authorization request the auth module will
query all known authorization info for a possible candidate (the match
must be for the host, port, scheme and realm). If no suitable info is
found, or if the server rejects any info found, an authorization handler
is called to try and get the necessary info from the user; if the user
does not give any information, or if the information she gives is also
rejected, then the retrying is terminated and the last failure status
returned to the caller. The default handler currently only understands
requests for the 'Basic' and 'Digest' authorization schemes; you may
however set your own handler via the <A
HREF="api/HTTPClient.AuthorizationInfo.html#setAuthHandler(HTTPClient.AuthorizationHandler)">AuthorizationInfo.setAuthHandler()</A>
method.  The handler given must implement the <A
HREF="api/HTTPClient.AuthorizationHandler.html">AuthorizationHandler</A>
interface.  To disable the handler completely give <var>null</var> for
the handler. To prevent the popup box from appearing use <A
HREF="api/HTTPClient.HTTPConnection.html#setAllowUserInteraction(boolean)">setAllowUserInteraction(false)</A>.

<P>A server (or proxy) may send multiple authorization challenges in the
response, in which case the above algorithm is modified to go through the
list of challenges in the same order as they were sent, trying to get
authorization info for each challenge in the list and going to the next
challenge if either no info was found or the server rejects that info. If
the end of the list is reached without achieving authorization then the
authorization handler is called on each challenge (in the same order)
until either an authorization request is successful, the authorization
handler returns null (e.g. when the Cancel button in the default popup
box is activated) or the list is exhausted, in which case the response to
the last failed request is returned.


<H3>RedirectionModule</H3>

<P>This module handles the redirection status codes 301, 302, 303, 305
and 307. 301 and 307 responses are only redirected if the request method
was GET or HEAD; this is because redirecting, say, a POST blindly might
lead to undesired behaviour, as the circumstances leading to the POST
might have changed. 302 and 303 are treated identically: the new request
to the new location is done using GET (this is what many cgi's expect -
they are basically directing you to a prefabricated answer). 305 is only
honored if the connection is not already using a proxy.

<P>This module also keeps a list of permanently redirected urls (status
code 301) and will preemptively redirect requests for these. This list is
volatile (i.e. it will be lost when the client exits).


<H3><A HREF="api/HTTPClient.CookieModule.html" NAME="cookie_module">CookieModule</A></H3>

<P>This module implements cookies as defined by Netscape's <A
HREF="http://home.netscape.com/newsref/std/cookie_spec.html">cookie
spec</A>.  Whenever the server tries to set a cookie a cookie handler is
invoked to see whether this cookie should be set. The default handler
brings up a popup describing the cookie and allowing the user to accept
or reject it; the user may also summarily accept or reject cookies from
whole domains. You may substitute you own cookie handler using the <A
HREF="api/HTTPClient.CookieModule.html#setCookiePolicyHandler(HTTPClient.CookiePolicyHandler)">setCookiePolicyHandler()</A>
method. If you set the handler to <var>null</var> then all cookies will
be accepted. If you do not want any cookies to be accepted then either
remove the CookieModule from the list of modules or set your own handler
which always returns <var>false</var>. The handler must implement the <A
HREF="api/HTTPClient.CookiePolicyHandler.html">CookiePolicyHandler</A>
interface.


<H3>ContentEncodingModule</H3>

<P>Servers may apply various content encodings to the content. The most
widely used encodings are compressions: <var>gzip</var>,
<var>compress</var> and <var>deflate</var>.  If running under JDK 1.1 or
later, this module will handle the <var>gzip</var> and <var>deflate</var>
content encodings by pushing an appropriate decoding stream; this means
that the data read from <A
HREF="api/HTTPClient.HTTPResponse.html#getInputStream()">getInputStream()</A>
will be the clear text. The <var>Content-Encoding</var> header is also
modified appropriately.

<P>If running under JDK 1.0.2 this module is not loaded in the first
place. The simple reason for this is that I'm too lazy to write my own
gzip and deflate decompression streams which are part of the java core
libraries as of JDK 1.1.

<P>You might want to consider disabling this module if you are using the
HTTPClient for things like web-copying where storing the compressed
document makes sense.


<H3>TransferEncodingModule</H3>

<P>This is similar to the ContentEncoding module except that it applies
to transfer encodings. It also handles <var>gzip</var> and
<var>deflate</var> encodings and is also only loaded if running under JDK
1.1 or later.


<H3>ContentMD5Module</H3>

<P>Some servers may generate a <var>Content-MD5</var> header which
contains an MD5 hash of the message body (after any content encoding, but
before any transport encoding is applied). If this header is present this
module will push a stream which calculates the MD5 hash of the body. When
the stream is closed or the end of the data is reached the calculated
hash is compared to the one in the <var>Content-MD5</var> header and if
they don't match an <var>IOException</var> is thrown.

<H3>DefaultModule</H3>

<P>This handles the response stati 408 (request timeout) and 411
(length required).


<H3>RetryModule</H3>

<P>This module is special. It is responsible for automatically retrying
requests which were aborted due to an IOException on the socket. It is
unlike other modules in that it is closely tied in to the core code,
instead of just manipulating the request and response structures as
other modules do. The code in this module could of been put in with the
rest of the core code, but moving it to a module has the advantage that
this automatic retrying of requests may be disabled using the standard
mechanism of removing modules.


<H3>Ordering the Modules</H3>

<P>The handlers in the modules are invoked in the order the modules are
placed in the list. Because of certain constraints between modules this
order is important. The default order for the supplied modules is:

<OL>
<LI>RetryModule
<LI>CookieModule
<LI>RedirectionModule
<LI>AuthorizationModule
<LI>DefaultModule
<LI>TransferEncodingModule
<LI>ContentMD5Module
<LI>ContentEncodingModule
</OL>

However the constraints impose only a partial ordering, so that the
above order may be changed as long as the following restrictions are
observed:

<UL>
<LI>The RetryModule <em>must</em> be first. It catches a special
    <var>RetryException</var>, which is thrown by the core code. If it
    were not the first module it would not be able to catch this
    exception.
<LI>The TransferEncoding module must precede any module which handles
    the response message (such as the ContentEncoding module and the
    ContentMD5Module). There are a number of reasons for this, but
    basically it's because all the headers refer to the message before
    transport encoding is applied.
<LI>The ContentMD5 module must precede the ContentEncoding module, as
    the hash is calculated for the encoded message.
</UL>


<H2><A NAME="properties">Properties recognized by HTTPClient</A></H2>

<P>There are a number of properties which are used by the HTTPClient.
Most are documented somewhere in the api docs. Some of the properties
may contain a list of elements, in which case the elements are separated
by vertical bars ("|"). White space is ignored, except that a <tt>"| |"</tt>
produces an empty element whereas <tt>"||"</tt> is treated like a single
delimiter (i.e. <tt>"|"</tt>).

Here is summary of all properties recognized:

<DL>
<DT>http.proxyHost
    <DD>Read by <A
	HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>.
	Used to specify the http proxy to use. See <A
	HREF="api/HTTPClient.HTTPConnection.html#setProxyServer(java.lang.String, int)">setProxyServer()</A>
	for more info. This is the same property that is used by Sun's JDK
	1.1 (and later).

<DT>http.proxyPort
    <DD>Read by <A
	HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>.
	Used to specify the http proxy to use. See <A
	HREF="api/HTTPClient.HTTPConnection.html#setProxyServer(java.lang.String, int)">setProxyServer()</A>
	for more info. This is the same property that is used by Sun's JDK
	1.1 (and later).

<DT>proxySet
    <DD>Read by <A
	HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>.
	Obsolete. Used by Sun's JDK 1.0.2. If <var>http.proxyHost</var>
	is not set and <var>proxySet</var> is true, then the default
	proxy is set using the values in <var>proxyHost</var> and
	<var>proxyPort</var>.

<DT>proxyHost
    <DD>Read by <A
	HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>.
	Obsolete. Used by Sun's JDK 1.0.2. If <var>http.proxyHost</var>
	is not set and <var>proxySet</var> is true, then the default
	proxy is set using the values in <var>proxyHost</var> and
	<var>proxyPort</var>.

<DT>proxyPort
    <DD>Read by <A
	HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>.
	Obsolete. Used by Sun's JDK 1.0.2. If <var>http.proxyHost</var>
	is not set and <var>proxySet</var> is true, then the default
	proxy is set using the values in <var>proxyHost</var> and
	<var>proxyPort</var>.

<DT>HTTPClient.nonProxyHosts
    <DD>Read by <A
	HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>.
	Used to specify a list hosts for which no http proxy is to be
	used. See <A
	HREF="api/HTTPClient.HTTPConnection.html#dontProxyFor(java.lang.String)">dontProxyFor()</A>
	for more info.

<DT>http.nonProxyHosts
    <DD>Read by <A
	HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>.
	Used to specify a list hosts for which no http proxy is to be
	used. See <A
	HREF="api/HTTPClient.HTTPConnection.html#dontProxyFor(java.lang.String)">dontProxyFor()</A>
	for more info. This is the same property that is used by Sun's
	JDK 1.1 (and later).

<DT>HTTPClient.socksHost
    <DD>Read by <A
	HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>.
	Used to specify the SOCKS proxy host. See <A
	HREF="api/HTTPClient.HTTPConnection.html#setSocksServer(java.lang.String, int, int)">setSocksServer()</A>
	for more info.

<DT>HTTPClient.socksPort
    <DD>Read by <A
	HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>.
	Used to specify the SOCKS proxy port. See <A
	HREF="api/HTTPClient.HTTPConnection.html#setSocksServer(java.lang.String, int, int)">setSocksServer()</A>
	for more info.

<DT>HTTPClient.socksVersion
    <DD>Read by <A
	HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>.
	Used to specify the SOCKS proxy version. See <A
	HREF="api/HTTPClient.HTTPConnection.html#setSocksServer(java.lang.String, int, int)">setSocksServer()</A>
	for more info.

<DT>HTTPClient.Modules
    <DD>Read by <A
	HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>.
	Used to define the default list of modules. See <A
	HREF="api/HTTPClient.HTTPConnection.html#addDefaultModule(java.lang.Class, int)">HTTPConnection.addDefaultModule()</A>
	for more info.

<DT>HTTPClient.disable_pipelining
    <DD>Read by <A
	HREF="api/HTTPClient.HTTPConnection.html">HTTPConnection</A>.
	Used to disable all pipelining. This should never be needed, but
	you may encounter a server which displays problems when pipelining
	requests. Setting this property to <var>true</var> will cause
	the HTTPClient to stall each request until the headers from the
	response to the previous request have been received and parsed.

<DT>HTTPClient.cookies.hosts.accept
    <DD>Read by <A
	HREF="api/HTTPClient.CookieModule.html">CookieModule</A>.
	Used to initialize the list of hosts and domains from which to
	always accept cookies. See <A
	HREF="api/HTTPClient.CookieModule.html#setCookiePolicyHandler(HTTPClient.CookiePolicyHandler)">setCookiePolicyHandler()</A>
	for more info.

<DT>HTTPClient.cookies.hosts.reject
    <DD>Read by <A
	HREF="api/HTTPClient.CookieModule.html">CookieModule</A>.
	Used to initialize the list of hosts and domains from which to
	always reject cookies. See <A
	HREF="api/HTTPClient.CookieModule.html#setCookiePolicyHandler(HTTPClient.CookiePolicyHandler)">setCookiePolicyHandler()</A>
	for more info.

<DT>http.agent
    <DD>Read by <A
	HREF="api/HTTPClient.HttpURLConnection.html">HttpURLConnection</A>.
	If set then the "User-Agent" header is set to this property's value.
</DL>


<H2><A NAME="headers">HTTP Headers</A></H2>

<P>All request methods accept optional headers to be sent with the request.
Here are a list of possible request and response headers as defined in
the HTTP/1.1 spec. I have added some comments to some of them, but for
further info I recommend getting the <A HREF="#specs">specs</A> (every
header is described in a paragraph of its own in the spec, so you can
read just the part that interests you and ignore the rest).


<H3>Request Headers</H3>

<ul>
<li><var>Cache-Control</var>
<li><var>Connection</var> - used for persistent connections
<li><var>Date</var> - use only in PUT/POST; even then optional
<li><var>Keep-Alive</var> - used for persistent connections (HTTP/1.0 only)
<li><var>Pragma</var>
<li><var>Transfer-Encoding</var> - set by the client as necessary
<li><var>Upgrade</var>
<li><var>Via</var>
</ul>
<ul>
<li><var>Accept</var>
<li><var>Accept-Charset</var>
<li><var>Accept-Encoding</var> - set by the ContentEncoding module
<li><var>Accept-Language</var>
<li><var>Authorization</var> - generated by HTTPClient as necessary
<li><var>From</var>
<li><var>Host</var> - set by HTTPClient
<li><var>If-Modified-Since</var> - the server returns 304 if the document
    was not modified
<li><var>If-Match</var> - the server returns 412 if the match fails
<li><var>If-NoneMatch</var> - the server returns 304 if the match succeeds
<li><var>If-Range</var>
<li><var>If-Unmodified-Since</var> - the server returns 412 if modified
<li><var>Max-Forwards</var> - used with TRACE and OPTIONS
<li><var>Proxy-Authorization</var> - generated by HTTPClient as necessary
<li><var>Range</var>
<li><var>Referer</var>
<li><var>User-Agent</var> - generated by HTTPClient; can be modified
</ul>
<ul>
<li><var>Allow</var> - only with PUT
<li><var>Content-Base</var>
<li><var>Content-Encoding</var> - examples: gzip, compress, deflate
<li><var>Content-Language</var>
<li><var>Content-Length</var> - set by HTTPClient
<li><var>Content-MD5</var>
<li><var>Content-Range</var>
<li><var>Content-Type</var>
</ul>


<H3>Response Headers</H3>

<ul>
<li><var>Cache-Control</var>
<li><var>Connection</var> - used for persistent connections
<li><var>Date</var> - date that the document was delivered
    (<strong>not</strong> when it was last modified)
<li><var>Keep-Alive</var> - used for persistent connections (HTTP/1.0 only)
<li><var>Pragma</var>
<li><var>Transfer-Encoding</var> - HTTPClient handles <var>chunked</var>
    in the core code; <var>gzip</var> and <var>deflate</var> are handled
    by the TransferEncoding module.
<li><var>Upgrade</var> - sent with a 101 response; 
<li><var>Via</var> - carries a list of proxies that were involved in
    returning the request; especially interesting for TRACE and OPTIONS
    requests.
</ul>
<ul>
<li><var>Age</var> - from caches
<li><var>Location</var> - sent with a redirection status code;
    since HTTPClient automatically handles 301, 302, 303, 305 and 307 status
    codes this field is seldom seen.
<li><var>Proxy-Authenticate</var> - read by HTTPClient
<li><var>Public</var>
<li><var>Retry-After</var> - optionally sent with a 503 status
<li><var>Vary</var>
<li><var>Warning</var>
<li><var>WWW-Authenticate</var> - read by HTTPClient
</ul>
<ul>
<li><var>Accept-Ranges</var>
<li><var>Allow</var> - with a 405 status
<li><var>Content-Base</var>
<li><var>Content-Encoding</var> - <var>gzip</var> and <var>deflate</var> are
     handled by the ContentEncoding module.
<li><var>Content-Language</var>
<li><var>Content-Length</var>
<li><var>Content-Location</var>
<li><var>Content-MD5</var> - handled by the ContentMD5 module.
<li><var>Content-Range</var>
<li><var>Content-Type</var>
<li><var>ETag</var>
<li><var>Expires</var> - the date when the document expires
<li><var>Last-Modified</var> - the date the document was last modified
</ul>


<H1><A NAME="specs">Further Reading</A></H1>

<DL>
<DD> <IMG ALT="*" SRC="images/greenball.gif">
     <A HREF="http://www.w3.org/pub/WWW/Protocols/">General HTTP Info at W3C</A>
<DD> <IMG ALT="*" SRC="images/greenball.gif">
     <A HREF="http://ds.internic.net/rfc/rfc1945.txt">HTTP/1.0 Spec (RFC 1945)
     </A>
<DD> <IMG ALT="*" SRC="images/greenball.gif">
     <A HREF="http://ds.internic.net/rfc/rfc2068.txt">HTTP/1.1 Spec (RFC 2068)
     </A>
</DL>


<P>
<A HREF="index.html">
<IMG SRC="images/back.gif" ALT="[HTTPClient]"></A>
<HR>

<ADDRESS>
Ronald Tschal&auml;r / 30. January 1998 /
<A HREF="mailto:ronald@innovation.ch">ronald@innovation.ch</A>.
</ADDRESS>

</BODY>

</HTML>

